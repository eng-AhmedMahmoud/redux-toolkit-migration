---
title: API Migration Guide
description: A comprehensive guide for migrating to the new API implementation
---

import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs'

This guide covers the migration process to the new API implementation, focusing on two main aspects:
<br/><br/> 1 -> forming the API <br/>  2 -> using it in your application.

## Forming the API

<Tabs defaultValue="old" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="old">Previous Implementation</TabsTrigger>
    <TabsTrigger value="new">New Implementation (glados.ts)</TabsTrigger>
  </TabsList>
  <TabsContent value="old">
```typescript
// Previous API implementation will be compared here
```
  </TabsContent>
  <TabsContent value="new">
```typescript
// New glados.ts implementation will be added here
```
  </TabsContent>
</Tabs>

## Using the API

### In Selectors

The new API can be used with selectors to dynamically update state. Here's how to implement selectors with the API:

<Tabs defaultValue="selector" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="selector">Selector Implementation</TabsTrigger>
  </TabsList>
  <TabsContent value="selector">
```typescript
const createHardwareDetailGroupSelector = createAppSelector(
  [
    state => state.vvlDeviceDetailsApp.salesChannel,
  ],
  salesChannel => getHardwareDetailGroup.select({ 
    salesChannel: salesChannel!, 
  }),
);

const selectHardwareDetailGroupQuery = createAppSelector(
  [
    state => state,
    createHardwareDetailGroupSelector,
  ],
  (state, selector) => selector(state),
);

const selectDevice = createAppSelector(
  [
    selectHardwareDetailGroupQuery,
  ],
  query => query?.data || null,
);

const selectOptionsLoadingFlag = createAppSelector(
  [
    selectHardwareDetailGroupQuery,
  ],
  state => state.isLoading,
);

const selectOptionsErrorsFlag = createAppSelector(
  [
    selectHardwareDetailGroupQuery,
  ],
  state => state.isError,
);

const selectDeviceName = createAppSelector(
  [selectDevice],
  (device: HardwareDetailGroupResponse | null): string | null => 
    device?.data.modelName || null,
);
```
  </TabsContent>
 
</Tabs>

### In Listeners

Listeners are used to perform side effects in response to API actions:

<Tabs defaultValue="listeners" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="listeners">Listener Implementation</TabsTrigger>
  </TabsList>
  <TabsContent value="listeners">
```typescript
setDefaultState: () => startAppListening({
  actionCreator: setDefaultState,
  effect: (_action, listenerApi) => {
    const state = listenerApi.getState();
    const deviceId = selectDeviceId(state);
    const salesChannel = selectSalesChannel(state) as SalesChannel;
    
    deviceId 
      ? listenerApi.dispatch(getHardwareDetailGroup.initiate({ salesChannel }))
      : redirectToDop();
  },
}),

getDeviceFulfilled: () => startAppListening({
  matcher: getHardwareDetailGroup.matchFulfilled,
  effect: (_action, listenerApi) => {
    const state = listenerApi.getState();
    const atomicId = selectAtomicId(state);
    listenerApi.dispatch(setAtomicId({ atomicId }));
    
    const salesChannel = selectSalesChannel(state) as SalesChannel;
    const isTradeIn = selectIsTradeIn(state);
    const devicePayload = _action.payload;
    
    listenerApi.dispatch(setDevicePayload(devicePayload));
    listenerApi.dispatch(getTariffWithHardware.initiate({ 
      salesChannel, 
      isTradeIn 
    }));
  },
}),
```
  </TabsContent>
</Tabs>

### In Extra Reducers

Extra reducers can be used to handle asynchronous logic without using createAsyncThunk:

<Tabs defaultValue="reducers" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="reducers">Extra Reducers Implementation</TabsTrigger>
    <TabsTrigger value="explanation">Explanation</TabsTrigger>
  </TabsList>
  <TabsContent value="reducers">
```typescript
extraReducers: builder => {
  builder
    .addMatcher(
      getHardwareDetailGroup.matchFulfilled,
      (state, action) => {
        const { atomics } = action.payload.data;
        
        if (
          !state.atomicId || 
          !atomics.some(atomic => atomic.hardwareId === state.atomicId)
        ) {
          const defaultAtomic = atomics.find(
            atomic => atomic.defaultAtomicDevice
          );
          state.atomicId = defaultAtomic?.hardwareId || null;
        }
        
        const currentAtomic = atomics.find(
          item => item.hardwareId === state.atomicId
        );
        state.currentColor = currentAtomic?.color || null;
        state.currentCapacity = currentAtomic?.capacity || null;
      },
    )
}
```
  </TabsContent>
  <TabsContent value="explanation">
This extra reducer handles the successful completion of the `getHardwareDetailGroup` action by:
1. Checking if the current atomicId is valid
2. Setting a default atomic device if needed
3. Updating the current color and capacity based on the selected atomic device
  </TabsContent>
</Tabs>